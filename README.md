# gocue

A robust and compliant CUE sheet parser for Go (Golang), designed to handle both standard-compliant and real-world, non-standard files with ease.

`gocue` provides a simple API to parse `.cue` files into structured Go types, making it easy to build applications for audio splitting, metadata extraction, and music library management. It has zero external dependencies.

## Features

*   **Comprehensive Parsing**: Supports all standard CUE sheet commands, including `CATALOG`, `CDTEXTFILE`, `FILE`, `TRACK`, `INDEX`, `PREGAP`, `POSTGAP`, `ISRC`, `FLAGS`, and all metadata fields (`TITLE`, `PERFORMER`, `SONGWRITER`).
*   **Resilient to Quirks**: Specifically designed to handle non-standard CUE files commonly generated by programs like Exact Audio Copy (EAC), which may place `INDEX` commands before their associated `TRACK`.
*   **Easy-to-Use API**: A single `Parse()` function is all you need to get a fully structured `Cuesheet` object.
*   **Convenient Helper Methods**: Includes utility methods like `track.Duration()` to automatically calculate a track's length and `timecode.AsDuration()` to convert CUE timestamps into `time.Duration`.
*   **Detailed Error Reporting**: Errors include the line number and a clear description of the parsing issue.
*   **Zero Dependencies**: A lightweight, pure Go module that's easy to integrate into any project.

## Installation

```sh
go get github.com/theurs/gocue
```


## Quick Start

Here's a simple example of how to parse a CUE sheet from a string:

```go
package main

import (
	"fmt"
	"log"
	"strings"
	
	"gocue" // or "github.com/theurs/gocue"
)

func main() {
	cueData := `
PERFORMER "Massive Attack"
TITLE "Mezzanine"
FILE "Massive Attack - Mezzanine.flac" WAVE
  TRACK 01 AUDIO
    TITLE "Angel"
    PERFORMER "Massive Attack"
    INDEX 01 00:00:00
  TRACK 02 AUDIO
    TITLE "Risingson"
    PERFORMER "Massive Attack"
    INDEX 01 06:19:35
`

	// Use strings.NewReader to create an io.Reader from the string
	reader := strings.NewReader(cueData)

	sheet, err := gocue.Parse(reader)
	if err != nil {
		log.Fatalf("Failed to parse CUE sheet: %v", err)
	}

	fmt.Printf("Album: %s\n", sheet.Title)
	fmt.Printf("Artist: %s\n", sheet.Performer)
	fmt.Println("--------------------")

	for _, file := range sheet.Files {
		fmt.Printf("Source File: %s (%s)\n", file.Name, file.Type)
		for _, track := range file.Tracks {
			fmt.Printf("  Track %02d: %s\n", track.Number, track.Title)
			fmt.Printf("    Start Time: %s\n", track.StartTime())
			fmt.Printf("    Calculated Duration: %v\n", track.Duration())
		}
	}
}
```

## API and Data Structures

The library's API is centered around the `Parse` function and the structs that model the CUE sheet.

### `func Parse(r io.Reader) (*Cuesheet, error)`

This is the main entry point. It reads from any `io.Reader` and returns a pointer to a `Cuesheet` struct or an error if parsing fails.

### Core Structs

*   **`Cuesheet`**: The root object representing the entire `.cue` file.
    *   `Title`, `Performer`, `Songwriter`: Global metadata for the album.
    *   `Catalog`: The Media Catalog Number (MCN).
    *   `Files`: A slice of `*File` structs, one for each `FILE` command.
    *   `Rem`: A slice of strings containing all `REM` comments.

*   **`File`**: Represents a `FILE` block, linking to a physical media file.
    *   `Name`: The filename (e.g., `"album.wav"`).
    *   `Type`: The file type (e.g., `WAVE`, `MP3`, `BINARY`).
    *   `Tracks`: A slice of `*Track` structs defined within this `FILE` block.

*   **`Track`**: Represents a `TRACK` block.
    *   `Number`: The track number (1-99).
    *   `Type`: The track data type (e.g., `AUDIO`, `MODE1/2352`).
    *   `Title`, `Performer`, `Songwriter`: Track-specific metadata.
    *   `ISRC`: The International Standard Recording Code.
    *   `Indices`: A slice of `Index` structs for this track.
    *   **`StartTime() Timecode`**: A helper meth
    od that returns the `INDEX 01` timecode.
    *   **`Duration() time.Duration`**: A helper method that calculates the track's duration by finding the start time of the next track. Returns `0` for the very last track in the sheet, as its end time cannot be determined from the CUE data alone.

*   **`Timecode`**: Represents the `MM:SS:FF` format.
    *   `Minutes`, `Seconds`, `Frames`: The component parts.
    *   **`AsDuration() time.Duration`**: Converts the timecode to a standard `time.Duration`.
    *   **`TotalFrames() int`**: Converts the timecode into an absolute number of frames (at 75 frames/second).

## Advanced Usage: Handling Real-World Files

A key strength of `gocue` is its ability to handle common issues found in CUE sheets in the wild.

### Problem 1: Non-Standard Syntax

Some rippers generate CUE files where an `INDEX` command appears before the `TRACK` it belongs to. This parser handles that pattern automatically.

```cue
// This is invalid according to the spec, but gocue parses it correctly.
FILE "01. Track One.wav" WAVE
    INDEX 01 00:00:00  <-- Appears before TRACK
  TRACK 01 AUDIO
    TITLE "Track One"
```

### Problem 2: Mismatched File Extensions

It's common for a `.cue` file to reference a `.wav` file, even when the user has re-encoded the audio to `.flac` or another format. Your application code should account for this.

Here is a robust function to find the correct audio file:

```go
// findActualAudioFile attempts to locate the real audio file on disk.
func findActualAudioFile(cuePath, filenameFromCue string) (string, error) {
	basePath := filepath.Join(filepath.Dir(cuePath), filenameFromCue)

	// 1. Check if the original filename exists
	if _, err := os.Stat(basePath); err == nil {
		return basePath, nil
	}

	// 2. If not, try common lossless alternatives
	possibleExtensions := []string{".flac", ".ape", ".wv"}
	baseNameWithoutExt := strings.TrimSuffix(filenameFromCue, filepath.Ext(filenameFromCue))

	for _, ext := range possibleExtensions {
		newFilename := baseNameWithoutExt + ext
		newPath := filepath.Join(filepath.Dir(cuePath), newFilename)
		if _, err := os.Stat(newPath); err == nil {
			log.Printf("INFO: Audio file '%s' not found, using '%s' instead.", filenameFromCue, newFilename)
			return newPath, nil
		}
	}

	return "", fmt.Errorf("could not find audio file '%s' or any alternatives", filenameFromCue)
}
```

## Full Example: Generating `ffmpeg` Commands

This example puts everything together to generate a script for splitting a single-file album into individual, tagged tracks.

*(This code can be found in the `examples/` directory.)*

```go
package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"gocue"
)

// (include findActualAudioFile and sanitizeFilename helpers here)

func main() {
	if len(os.Args) < 2 {
		log.Fatal("Usage: go run main.go <path/to/your.cue>")
	}
	cuePath := os.Args[1]

	f, err := os.Open(cuePath)
	if err != nil {
		log.Fatalf("FATAL: Failed to open CUE file '%s': %v", cuePath, err)
	}
	defer f.Close()

	sheet, err := gocue.Parse(f)
	if err != nil {
		log.Fatalf("FATAL: Failed to parse CUE file: %v", err)
	}
	
	fmt.Println("#!/bin/sh")
	fmt.Printf("# ffmpeg commands for: %s - %s\n\n", sheet.Performer, sheet.Title)

	for _, file := range sheet.Files {
		sourceAudioPath, err := findActualAudioFile(cuePath, file.Name)
		if err != nil {
			log.Printf("WARN: Skipping file '%s': %v", file.Name, err)
			continue
		}

		for _, track := range file.Tracks {
			startTime := track.StartTime().AsDuration()
			duration := track.Duration()
			outputFileName := fmt.Sprintf("%02d - %s.ogg", track.Number, sanitizeFilename(track.Title))

			// Base command
			cmd := fmt.Sprintf(
				`ffmpeg -i "%s" -ss %f -vn -map_metadata -1`,
				sourceAudioPath,
				startTime.Seconds(),
			)

			// Add duration if it's not the last track
			if duration > 0 {
				cmd += fmt.Sprintf(" -t %f", duration.Seconds())
			}

			// Add codec and output file
			cmd += fmt.Sprintf(` -c:a libvorbis -q:a 5 "%s"`, outputFileName)

			// Add metadata
			cmd += fmt.Sprintf(
				` -metadata artist="%s" -metadata album_artist="%s" -metadata album="%s" -metadata title="%s" -metadata track="%d"`,
				track.Performer, sheet.Performer, sheet.Title, track.Title, track.Number,
			)
			fmt.Println(cmd)
		}
	}
}
```

## Contributing

Contributions are welcome! Please feel free to submit a pull request or open an issue for bugs, feature requests, or improvements.

## License

This project is licensed under the MIT License. See the `LICENSE` file for details.